;====================================================================
; Main.asm file generated by New Project wizard
;
; Created:   sex nov 1 2024
; Processor: PIC16F887
; Compiler:  MPASM (Proteus)
;====================================================================

;====================================================================
; DEFINITIONS
;====================================================================

#include p16f887.inc                ; Include register definition file

;====================================================================
; VARIABLES
;====================================================================
CBLOCK  0x20           
      count1
   err
   steep
   ystep
   temp
   X0
   X0old
   X0tri
   X1
   X1old
   X1tri
   X2tri
   dx
   temp_x
   temp_x1
   Y0
   Y0old
   Y0tri
   Y1
   Y1old
   Y1tri
   Y2tri
   dy
   temp_y
   Altura
   AlturaOld
   Largura
   LarguraOld
   eF
   ddF_x
   ddF_y
   X
   Y
   Raio
   RaioOld
   COR1
   COR2
   COR3
ENDC
;====================================================================
; RESET and INTERRUPT VECTORS
;====================================================================

      ; Reset Vector
RST   code  0x0 
      goto  começo

;====================================================================
; CODE SEGMENT
;====================================================================

PGM   code
começo
   BSF  STATUS, RP0    
   BCF  STATUS, RP1    
   CLRF TRISC                
   CLRF TRISB		      
   CLRF TRISD
   CLRF SSPSTAT              
										   
   BCF  STATUS, RP0    
   BCF  STATUS, RP1               
   CLRF PORTD      
   CLRF INTCON      ; Desabilitar interrupções
   
   MOVLW 0x22                
   MOVWF SSPCON
   MOVLW 0x30       ; Configurando o pre-scale do timer1 para 8
   MOVWF T1CON
 
beginDisplay
   MOVLW 0X01       ; Comando SWRESET
   CALL enviarComando
   CALL delay130ms
   
   MOVLW 0X11       ; Comando SLPOUT Sleep Out
   CALL enviarComando
   CALL delay130ms 
   
   MOVLW 0X29       ; Comando DISPON Display On
   CALL enviarComando
   CALL delay130ms

definicaoVariaveis:
   ; Variáveis para mudança de cor RGB
   MOVLW .0       
   MOVWF COR1 ; VERMELHO
   MOVLW .0       
   MOVWF COR2 ; VERDE
   MOVLW .0    
   MOVWF COR3 ; AZUL
   
   ;Parâmetros para posição inical e final do desenho
   MOVLW .50
   MOVWF X0
   MOVWF X0old
   MOVLW .80
   MOVWF Y0
   MOVWF Y0old
   
   MOVLW .131
   MOVWF X1
   MOVWF X1old
   MOVLW .161
   MOVWF Y1
   MOVWF Y1old
   
   ;Parâmetros para largura (L) e altura (H) do retângulo desenhado
   MOVLW .132
   MOVWF Largura
   MOVWF LarguraOld
   
   MOVLW .162
   MOVWF Altura
   MOVWF AlturaOld
   
   ;Parâmetros para o desenho dos  três pontos de um triângulo
   ;0:0 0:80 50:40
   MOVLW .0
   MOVWF X0tri
   MOVLW .0
   MOVWF Y0tri
   
   MOVLW .0
   MOVWF X1tri
   MOVLW .0
   MOVWF Y1tri
   
   MOVLW .0
   MOVWF X2tri
   MOVLW .0
   MOVWF Y2tri
   
   ;Parâmetro para Raio da circunferência 
   MOVLW .0
   MOVWF Raio
   
chamadaFuncoes:
    
;    CALL desenharRetanguloPreenchido 
    CALL desenharLinha
    
    MOVLW .20
    MOVWF X0
    MOVLW .150
    MOVWF Y0
    CALL desenharPixel
    
;    MOVLW .40
;    MOVWF X0
;    MOVLW .40
;    MOVWF Y0
;    MOVLW .20
;    MOVWF X1
;    MOVLW .20
;    MOVWF Y1
;    
;    CALL desenharLinha
    
    
    MOVLW .0       
    MOVWF COR1 ; VERMELHO
    MOVLW .0       
    MOVWF COR2 ; VERDE
    MOVLW .0    
    MOVWF COR3 ; AZUL

    
    

 
;   MOVLW .30
;   MOVWF X0
;   MOVLW .50
;   MOVWF Y0
;   CALL desenharPixel
;   MOVLW .70
;   MOVWF X0
;   MOVLW .20
;   MOVWF Y0
;   CALL desenharPixel
;   MOVLW .110
;   MOVWF X0
;   MOVLW .50
;   MOVWF Y0
;   CALL desenharPixel

loop
   CLRWDT
   GOTO  loop
   
desenharPixel:
    
   MOVF  X0, W
   MOVWF X1
   
   MOVF  Y0, W
   MOVWF Y1
   
   CALL definirIntervalo

   MOVF  X1old, W 
   MOVWF X1
   MOVF  Y1old, W
   MOVWF Y1
   
   
   MOVF COR1, W
   CALL enviarDados
   MOVF COR2, W
   CALL enviarDados
   MOVF COR3, W
   CALL enviarDados
   
   RETURN

desenharRetanguloPreenchido:
desenharReta:
   MOVF  X0     , W
   MOVWF temp
   ADDWF Largura, F
   MOVF  Y0     , W
   ADDWF Altura , F
   LoopPreenchimentoLinha
	CLRWDT
	BCF   STATUS , Z
	MOVF  X0     , W
	SUBWF Largura, W

	BTFSC STATUS , Z  
	   GOTO FimLoopPreenchimentoLinha
	   CALL desenharPixel
	INCF X0, F
	GOTO LoopPreenchimentoLinha

   FimLoopPreenchimentoLinha
      INCF  Y0  , F
      MOVF  temp, W
      MOVWF X0
      
      BCF   STATUS, Z
      MOVF  Y0    , W
      SUBWF Altura, W

      BTFSC STATUS, Z  
	 GOTO FimLoopPreenchimento
	 GOTO LoopPreenchimentoLinha
	 
   FimLoopPreenchimento
      MOVF  X0old, W
      MOVWF X0
      MOVF  Y0old, W
      MOVWF Y0
      MOVF  LarguraOld, W
      MOVWF Largura
      MOVF  AlturaOld , W
      MOVWF Altura
      RETURN

desenharRetangulo:
    MOVLW .1
    MOVWF Altura
    CALL desenharReta
   
    MOVLW .1
    MOVWF Largura
    CALL  desenharReta
    
    MOVF  Largura, W
    ADDWF X0, F
    MOVLW .1
    MOVWF Largura
    CALL  desenharReta
    
    MOVF  X0old, W
    MOVWF X0
    MOVF  Altura, W
    ADDWF Y0   , F
    MOVLW .1
    MOVWF Altura
    INCF  Largura
    CALL  desenharReta
    
    MOVF  X0old, W
    MOVWF X0
    MOVF  Y0old, W
    MOVWF Y0
    RETURN

   
; Variáveis temporárias e parâmetros
; X0: posição X do centro do círculo
; Y0: posição Y do centro do círculo
; Raio: raio do círculo
; F: valor de erro para o cálculo de Bresenham
; ddF_x: incremento do erro para X
; ddF_y: incremento do erro para Y
; X: variável de posição X temporária
; Y: variável de posição Y temporária

desenharCircunferenciaPreenchida:
    MOVF  Raio, W
    MOVWF RaioOld
    
    loopPreenchimento
	BCF STATUS, C
	MOVLW .2  
	SUBWF Raio, W                   
	BTFSC STATUS, Z              
	    GOTO fimLoopPreenchimento 
	    CALL desenharCircunferencia

	DECF Raio, F
	GOTO loopPreenchimento
	
    fimLoopPreenchimento
	MOVF  RaioOld, W
	MOVWF Raio
	RETURN
    
desenharCircunferencia:
    ; Inicializações para o algoritmo de Bresenham
    MOVF  Raio, W
    MOVWF RaioOld
    
    MOVF  Raio, W             
    MOVWF Y                     ; Y = Raio
    CLRF  X                     ; X = 0
    
    COMF  Raio, F
    INCF  Raio, F               ; R = -R
    MOVLW .1
    ADDWF Raio, W               ; Calcula 1 - Raio para F
    MOVWF eF                    ; Armazena F = 1 - Raio
    
    MOVLW .1
    MOVWF ddF_x                 ; ddF_x = 1
    
    MOVF  Raio, W
    ADDWF Raio, W               ; R já é -R, então -R+-R = -2*R
    MOVWF ddF_y			; ddF_y = -2 * Raio
    
    MOVF  RaioOld, W
    MOVWF Raio                  ; Volta R para o valor original

    ; Desenha os pontos iniciais do círculo
    CALL desenharBaseCircunferencia

   Loop_desenharCirculo
       ; Enquanto X < Y faça:
       BCF STATUS, C
       MOVF  X, W
       SUBWF Y, W                   ; W = Y - X, se (X < Y) STATUS<C> = 1 Se não STATUS<C> = 0 
       BTFSS STATUS, C              
       GOTO FimLoop_desenharCirculo ; Se STATUS<C> = 0 executa o fim do loop Se não continua o desenho
    

       ; Atualiza o valor de F e decrementar Y se necessário 
       BTFSS eF, 7              ; Verifica se o bit 7 (MSB) está setado
       GOTO AjusteY                 ; Se F >= 0, ajustar Y
       GOTO AjusteX                 ; Caso contrário, incrementar X

   AjusteY
       ; Atualiza Y, ddF_y e F
       DECF  Y    , F                ; y--
       INCF  ddF_y, F               
       INCF  ddF_y, F                ; ddF_y += 2
       MOVF  ddF_y, W
       ADDWF eF   , F                ; F += ddF_y

   AjusteX
       ; Incrementa X, ddF_x e F
       INCF  X    , F                ; x++
       INCF  ddF_x, F                
       INCF  ddF_x, F                ; ddF_x += 2
       MOVF  ddF_x, W
       ADDWF eF   , F                ; F += ddF_x

       CALL desenharPixelSimetricos  ; Desenha os 8 pontos simétricos

       GOTO Loop_desenharCirculo    ; Loop para próximo ponto

   FimLoop_desenharCirculo
       RETURN                       ; Fim da função

   ; Função para desenhar os pontos iniciais do círculo
   desenharBaseCircunferencia
       ; Desenha os quatro pontos iniciais do círculo
       MOVF  Y0, W
       MOVWF Y0old
       MOVF  X0, W
       MOVWF X0old
       
       MOVF  Raio, W
       ADDWF Y0  , F
       CALL  desenharPixel           ; (X0, Y0 + Raio)

       MOVF  Y0old, W
       MOVWF Y0
       
       MOVF  Raio, W
       SUBWF Y0  , W
       MOVWF Y0 
       MOVWF temp_y
       CALL  desenharPixel           ; (X0, Y0 - Raio)

       MOVF  Y0old, W
       MOVWF Y0
       
       MOVF  Raio , W
       ADDWF X0   , F
       CALL  desenharPixel           ; (X0 + Raio, Y0)

       MOVF  X0old, W
       MOVWF X0  
       
	MOVF  Raio , W
	SUBWF X0   , F
	CALL  desenharPixel           ; (X0 - Raio, Y0)
	
	MOVLW .1
	MOVWF Altura
	MOVF Raio, W
	MOVWF Largura
	ADDWF Largura, F
	CALL desenharReta

	MOVF  X0old, W
	MOVWF X0
       
	MOVF temp_y, W
	MOVWF Y0
	MOVLW .1
	MOVWF Largura
	MOVF Raio, W
	MOVWF Altura
	ADDWF Altura, F
	CALL desenharReta
       
       RETURN

   ; Função para desenhar os 8 pontos simétricos
   desenharPixelSimetricos
	MOVF  X , W	  	    
	ADDWF X0, W		    ; X0 = X0 + X
	MOVWF X0
	MOVWF temp_x
	MOVF  Y , W
	ADDWF Y0, F		    ; Y0 = Y0 + Y
	CALL  desenharPixel         ; Desenha o pixel em (X0 + X, Y0 + Y)
      
	MOVF  X0old, W
	MOVWF X0

	MOVF  X , W
	SUBWF X0, W		    ; X0 = X0 - X    
	MOVWF X0
	MOVWF temp_x1
	CALL desenharPixel            ; Desenha o pixel em (X0 - X, Y0 + Y)

	MOVF  X0old, W
	MOVWF X0
	MOVF  Y0old, W
	MOVWF Y0

	MOVF  X , W
	ADDWF X0, F		    ; X0 = X0 + X
	MOVF  Y , W		    
	SUBWF Y0, W		    ; Y0 = Y0 - y
	MOVWF Y0
	MOVWF temp_y
	CALL desenharPixel            ; Desenha o pixel em (X0 + X, Y0 - Y)
      
	MOVF temp_x, W
	MOVWF X0
	MOVF temp_y, W
	MOVWF Y0
	MOVLW .1
	MOVWF Largura
	MOVF Y, W
	MOVWF Altura
	ADDWF Altura, F
	CALL desenharReta
	
	MOVF temp_x1, W
	MOVWF X0
	MOVF temp_y, W
	MOVWF Y0
	MOVLW .1
	MOVWF Largura
	MOVF Y, W
	MOVWF Altura
	ADDWF Altura, F
	CALL desenharReta
      
      MOVF  X0old, W
      MOVWF X0

      MOVF temp_y, W
      MOVWF Y0
      MOVF  X , W
      SUBWF X0, F		    ; X0 = X0 - X
      CALL  desenharPixel           ; Desenha o pixel em (X0 - X, Y0 - Y)
      
      MOVF  X0old, W
      MOVWF X0
      MOVF  Y0old, W
      MOVWF Y0

      MOVF  Y , W
      ADDWF X0, F		    ; X0 = X0 + Y
      MOVF  X , W
      ADDWF Y0, W		    ; Y0 = Y0 + X
      MOVWF Y0
      MOVWF temp_x1
      CALL  desenharPixel           ; Desenha o pixel em (X0 + Y, Y0 + X)
      
      MOVF  X0old, W
      MOVWF X0

      MOVF  Y , W
      SUBWF X0, W		    ; X0 = X0 - Y
      MOVWF X0
      MOVWF temp_x
      CALL  desenharPixel           ; Desenha o pixel em (X0 - Y, Y0 + X)
      
      MOVF  X0old, W
      MOVWF X0
      MOVF  Y0old, W
      MOVWF Y0

	MOVF  Y , W
	ADDWF X0, F     		    ; X0 = X0 + Y
	MOVF  X , W		    
	SUBWF Y0, W		    ; Y0 = Y0 - X
	MOVWF Y0
	MOVWF temp_y
	CALL  desenharPixel           ; Desenha o pixel em (X0 + Y, Y0 - X)
      
	MOVF temp_x, W
	MOVWF X0
	MOVF temp_y, W
	MOVWF Y0
	MOVLW .1
	MOVWF Altura
	MOVF Y, W
	MOVWF Largura
	ADDWF Largura, F
	CALL desenharReta
	
	MOVF temp_x, W
	MOVWF X0
	MOVF temp_x1, W
	MOVWF Y0
	MOVLW .1
	MOVWF Altura
	MOVF Y, W
	MOVWF Largura
	ADDWF Largura, F
	CALL desenharReta
      
	MOVF temp_y, W
	MOVWF Y0
	MOVF  X0old, W
	MOVWF X0

      MOVF  Y , W
      SUBWF X0, F		    ; X0 = X0 - Y
      CALL  desenharPixel           ; Desenha o pixel em (X0 - Y, Y0 - X)
      
      MOVF  X0old, W
      MOVWF X0
      MOVF  Y0old, W
      MOVWF Y0

      RETURN
      
desenharTriangulo:
    MOVF  X0tri, W
    MOVWF X0
    MOVF  Y0tri, W
    MOVWF Y0
    MOVF  X1tri, W
    MOVWF X1
    MOVF  Y1tri, W
    MOVWF Y1
    CALL desenharLinha
    
    MOVF  X2tri, W
    MOVWF X0
    MOVF  Y2tri, W
    MOVWF Y0
    MOVF  X1tri, W
    MOVWF X1
    MOVF  Y1tri, W
    MOVWF Y1
    CALL desenharLinha
    
    MOVF  X0tri, W
    MOVWF X0
    MOVF  Y0tri, W
    MOVWF Y0
    MOVF  X0tri, W
    SUBWF X2tri, W
    MOVWF Largura
    MOVLW .1
    MOVWF Altura
    
    CALL desenharReta
    
    RETURN
    
     



desenharLinha:
; steep  - Flag para inclinação da linha
; dx     - Delta x
; dy     - Delta y
; err    - Erro inicial
; ystep  - Passo para y

   ; Calcula dy = abs(y1 - y0) e dx = abs(x1 - x0)=======================
   BCF   STATUS, C
   MOVF  Y0    , W
   SUBWF Y1    , W          ; W = y1 - y0
   MOVWF dy
   BTFSC STATUS, C          ; Se y1 >= y0, não precisamos inverter
      NOP                   ; dy = abs(y1 - y0)
   BTFSS STATUS, C
      CALL inverterDy	    ; Caso contrário, inverter o sinal
      
   BCF   STATUS, C
   MOVF  X0    , W
   SUBWF X1    , W          ; W = x1 - x0
   MOVWF dx		    ; dx = abs(x1 - x0)
   BTFSC STATUS, C
      NOP
   BTFSS   STATUS, C
      CALL inverterDx
   ;===========================================================
   ; Checa se steep = (dy > dx)================================
   BCF     STATUS, C
   MOVF    dx, W
   SUBWF   dy, W
   BTFSS   STATUS, C       ; Se dy > dx
      GOTO  dxMQdy
      
   MOVLW   .1              ; steep = 1 (true)
   MOVWF   steep
   GOTO    steepTrue
   
   dxMQdy
      CLRF steep           ; steep = 0 (false)
      GOTO checarX
    ;============================================================= 
    inverterDy
	COMF    dy, F           
	INCF    dy, F
	RETURN
    inverterDx
	COMF    dx, F           
	INCF    dx, F
	RETURN
      
    steepTrue;==================================================================
      ; Troca x0 e y0
      MOVF    X0  , W
      MOVWF   temp
      MOVF    Y0  , W
      MOVWF   X0
      MOVF    temp, W
      MOVWF   Y0
      
      ; Troca x1 e y1
      MOVF    X1  , W
      MOVWF   temp
      MOVF    Y1  , W
      MOVWF   X1
      MOVF    temp, W
      MOVWF   Y1
    ;===========================================================================  
    checarX;====================================================================
	; Se x0 > x1, trocar (x0, y0) e (x1, y1)
	BCF     STATUS, C
	MOVF    X0, W
	SUBWF   X1, W
	BTFSC   STATUS, C ; Se x0 > x1, trocar
	   GOTO x1MQx0
	
	MOVF    X0  , W   ; Troca x0 e x1
	MOVWF   temp
	MOVF    X1  , W
	MOVWF   X0
	MOVF    temp, W
	MOVWF   X1

	MOVF    Y0  , W   ; Troca y0 e y1
	MOVWF   temp
	MOVF    Y1  , W
	MOVWF   Y0
	MOVF    temp, W
	MOVWF   Y1
    ;===========================================================================
      
    x1MQx0;=====================================================================
	MOVF    dx, W
	MOVWF   err
	RRF     err, F  ; err = dx / 2

	; Define ystep
	MOVF    Y0, W
	SUBWF   Y1, W
	BTFSC   STATUS, C
	   GOTO y1MQy0  ; y1 > y0

	MOVLW   0xFF    ;-1 
	MOVWF   ystep
	GOTO    loopDesenhoLinha

	y1MQy0
	   MOVLW   .1
	   MOVWF   ystep
    ;===========================================================================
loopDesenhoLinha;===============================================================
    MOVF    X0, W
    SUBWF   X1, W
    BTFSS   STATUS, C         ; x0 > x1?
       GOTO fimDesenhoLinha   ; Se x0 > x1 para o loop

    ; Se steep == true, desenha (y0, x0), senão desenha (x0, y0)
    BCF     STATUS, Z
    MOVF    steep , W
    BTFSC   STATUS, Z
       GOTO desenharXY        ; Se steep = 0 (false)
       GOTO desenharYX

    desenharXY
	CALL  desenharPixel
	GOTO  pulo

    desenharYX
	MOVF  X0    , W       ; Troca a posição de X0 com Y0
	MOVWF temp_x
	MOVF  Y0    , W
	MOVWF temp_y

	MOVF  temp_y, W
	MOVWF X0
	MOVF  temp_x, W
	MOVWF Y0

	CALL  desenharPixel

	MOVF  temp_x, W
	MOVWF X0
	MOVF  temp_y, W
	MOVWF Y0

    pulo
	; Atualiza err e y0
	MOVF  dy , W
	SUBWF err, F

	BTFSS err, 7   ; err > 0? 
	   GOTO pularYstep ; Se err >= 0

	MOVF  ystep, W
	ADDWF Y0   , F ; Incrementa y0 de acordo com ystep

	MOVF  dx , W
	ADDWF err, F   ; Adiciona dx ao erro

    pularYstep
	INCF X0, F     ; Incrementa x0
	GOTO loopDesenhoLinha
;===============================================================================
fimDesenhoLinha
    MOVF  X0old, W
    MOVWF X0
    MOVF  Y0old, W
    MOVWF Y0
    RETURN
    
definirIntervalo:
    MOVLW 0X2A       ; Comando CASET Column Address Set
    CALL  enviarComando
    CALL  microDelay
    MOVLW 0X00
    CALL  enviarDados
    MOVF  X0, W
    CALL  enviarDados
    MOVLW 0X00
    CALL  enviarDados
    MOVF  X1, W       
    CALL  enviarDados

    MOVLW 0X2B       ; Comando RASET Row Address Set
    CALL  enviarComando
    CALL  microDelay
    MOVLW 0X00
    CALL  enviarDados
    MOVF  Y0, W
    CALL  enviarDados
    MOVLW 0X00
    CALL  enviarDados
    MOVF  Y1, W      
    CALL  enviarDados

    MOVLW 0X2C      ; Comando RAMWR Memory Write
    CALL  enviarComando
    CALL  microDelay
    RETURN
    
enviarComando:
   BCF STATUS, RP0    
   BCF STATUS, RP1
   BCF PORTB, 0      ; Definindo o envio de um comando
   MOVWF SSPBUF      ; Coloca o comando definido no buffer de transmissão
   RETURN
   
enviarDados:
   BCF STATUS, RP0    
   BCF STATUS, RP1
   BSF PORTB, 0      
   MOVWF SSPBUF
   CALL microDelay
   RETURN
   
delay130ms:
   MOVLW 0X02
   MOVWF count1
   
   begin1
      MOVLW 0x61      ; Configuração do tempo do timer  
      MOVWF TMR1H     ;...  
      MOVLW 0x4F      ;...  
      MOVWF TMR1L     ;...
       
      BSF T1CON, TMR1ON  ; Liga o Timer1
      BCF PIR1, TMR1IF   ; Limpa a flag de interrupção do Timer1 
      
      delayLoop
	 BTFSS PIR1, TMR1IF  ; Verifica se a flag TMR1IF foi acionada (timer1 extorou)
	 GOTO  delayLoop     ; Se não, continua no loop 
      BCF T1CON, TMR1ON  ; Desliga o Timer1
      BCF PIR1, TMR1IF   ; Limpa a flag de interrupção novamente
      
   DECFSZ count1
   GOTO begin1
   RETURN
   
microDelay:
   MOVLW 0xFF       
   MOVWF TMR1H       
   MOVLW 0xF0      
   MOVWF TMR1L     
    
   BSF T1CON, TMR1ON  
   BCF PIR1, TMR1IF    
   
   delayLoop1
      BTFSS PIR1, TMR1IF  
      GOTO  delayLoop1     
   BCF T1CON, TMR1ON 
   BCF PIR1, TMR1IF   
   RETURN

;====================================================================
      END
